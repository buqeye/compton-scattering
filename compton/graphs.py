import matplotlib as mplimport matplotlib.pyplot as pltfrom mpl_toolkits.axes_grid1 import AxesGridimport numpy as npfrom .constants import omega_lab_cusp, dsg_labelfrom mpl_toolkits.axes_grid1 import Dividerimport matplotlib.transforms as mtransformsimport warnings# AxesGrid aspect parameter can only be a bool, but a float is more flexible.# Copied and slightly edited from Divider classdef locate(self, nx, ny, nx1=None, ny1=None, axes=None, renderer=None):    """    Parameters    ----------    nx, nx1 : int        Integers specifying the column-position of the        cell. When *nx1* is None, a single *nx*-th column is        specified. Otherwise location of columns spanning between *nx*        to *nx1* (but excluding *nx1*-th column) is specified.    ny, ny1 : int        Same as *nx* and *nx1*, but for row positions.    axes    renderer    """    figW, figH = self._fig.get_size_inches()    x, y, w, h = self.get_position_runtime(axes, renderer)    hsizes = self.get_horizontal_sizes(renderer)    vsizes = self.get_vertical_sizes(renderer)    k_h = self._calc_k(hsizes, figW * w)    k_v = self._calc_k(vsizes, figH * h)    if self.get_aspect():        k = min(k_h, k_v)        a = self.get_aspect()  # This is the change to allow aspect to be float        ox = self._calc_offsets(hsizes, k)        oy = self._calc_offsets(vsizes, k * a)  # And this        ww = (ox[-1] - ox[0]) / figW        hh = (oy[-1] - oy[0]) / figH        pb = mtransforms.Bbox.from_bounds(x, y, w, h)        pb1 = mtransforms.Bbox.from_bounds(x, y, ww, hh)        pb1_anchored = pb1.anchored(self.get_anchor(), pb)        x0, y0 = pb1_anchored.x0, pb1_anchored.y0    else:        ox = self._calc_offsets(hsizes, k_h)        oy = self._calc_offsets(vsizes, k_v)        x0, y0 = x, y    if nx1 is None:        nx1 = nx + 1    if ny1 is None:        ny1 = ny + 1    x1, w1 = x0 + ox[nx] / figW, (ox[nx1] - ox[nx]) / figW    y1, h1 = y0 + oy[ny] / figH, (oy[ny1] - oy[ny]) / figH    return mtransforms.Bbox.from_bounds(x1, y1, w1, h1)# Monkey patch it! This should affect all calls to AxesGridDivider.locate = locateDEFAULT_CMAP = plt.get_cmap('gist_stern')# TICK_COLOR = 'lightgrey'# TICK_COLOR = '0.8'TICK_COLOR = 'k'CBAR_SIZE = 0.11TWO_COLUMN_WIDTH = 7.2ONE_COLUMN_WIDTH = 3.4def setup_rc_params():    fontsize = 8    black = 'k'    mpl.rcdefaults()  # Set to defaults    mpl.rc('text', usetex=True)    mpl.rcParams['font.size'] = fontsize    mpl.rcParams['text.usetex'] = True    mpl.rcParams['font.family'] = 'serif'    mpl.rcParams['axes.labelsize'] = fontsize    mpl.rcParams['axes.edgecolor'] = black    # mpl.rcParams['axes.xmargin'] = 0    mpl.rcParams['axes.labelcolor'] = black    mpl.rcParams['axes.linewidth']    mpl.rcParams['axes.titlesize'] = fontsize    mpl.rcParams['ytick.direction'] = 'in'    mpl.rcParams['xtick.direction'] = 'in'    mpl.rcParams['xtick.labelsize'] = fontsize    mpl.rcParams['ytick.labelsize'] = fontsize    mpl.rcParams['xtick.color'] = black    mpl.rcParams['ytick.color'] = black    mpl.rcParams['xtick.minor.size'] = 2.4    mpl.rcParams['ytick.minor.size'] = 2.4    mpl.rcParams['figure.titlesize'] = fontsize    mpl.rcParams['legend.title_fontsize'] = fontsize    mpl.rcParams['legend.fontsize'] = fontsize    mpl.rcParams['legend.edgecolor'] = 'inherit'  # inherits from axes.edgecolor, to match    mpl.rcParams['legend.facecolor'] = (1, 1, 1, 0.6)  # Set facecolor with its own alpha, so edgecolor is unaffected    mpl.rcParams['legend.fancybox'] = True    mpl.rcParams['legend.borderaxespad'] = 0.8    mpl.rcParams['legend.framealpha'] = None  # Do not set overall alpha (affects edgecolor). Handled by facecolor above    mpl.rcParams['patch.linewidth'] = 0.8  # This is for legend edgewidth, since it does not have its own option    mpl.rcParams['hatch.linewidth'] = 0.5    mpl.rc('savefig', transparent=False, bbox='tight', pad_inches=0.05, dpi=350, format='png')    mpl.rcParams['figure.dpi'] = 150def set_my_default_ticks(ax, tickcolor='k'):    ax.set_xticks([100, 200, 300])    # ax.set_xticks([50, 150, 250], minor=True)    # ax.set_xticks([50, 150, 250], minor=True)    ax.set_yticks([60, 120])    # ax.set_yticks([30, 90, 150], minor=True)    # ax.tick_params(direction='in', axis='both', which='both', bottom=True, top=True, left=True, right=True)    ax.tick_params(        direction='in', axis='both', which='both', bottom=True, top=False, left=True, right=False,        colors=tickcolor, labelcolor='k'    )    return axdef offset_scatterplot_data(n, ax=None):    """For adjusting the output from sns.scatterplot when the x-axis is categorical.    To be used in place of sns.swarmplot when you want the flexibility of scatterplot (i.e. markers)    n : int        The number of points per category    ax : Axes        The axis object, optional    """    if ax is None:        ax = plt.gca()    points = ax.collections[0].get_offsets().data    for i in range(len(points)):        points[i, 0] += ((i % n) + 1) / (n+1) - 0.5    ax.collections[0].set_offsets(points)    return axdef compute_vmax(*utils):    vmax_list = []    for util in utils:        vmax_list.append(util.max())    return np.log(np.average(np.exp(vmax_list)))def plot_subsets(util_dict, nucleon, omega, degrees, observables=None, subsets=None):    nucleons_all, observables_all, subsets_all = tuple(zip(*util_dict.keys()))    nucleons = np.unique(nucleons_all)    if observables is None:        observables = np.unique(observables_all)    if subsets is None:        subsets = np.unique(subsets_all)    n_omega = len(omega)    n_degrees = len(degrees)    if nucleon not in nucleons:        raise ValueError('nucleon must be in dict keys')    fig, axes = plt.subplots(len(observables), len(subsets), figsize=(TWO_COLUMN_WIDTH, 14), sharex=True, sharey=True)    for i, obs_i in enumerate(observables):        # Same colors within rows        # max_util = np.max([util_dict_trans_trunc_sets[obs_i, subset_name] for subset_name in subsets.keys()])        # min_util = np.min([util_dict_trans_trunc_sets[obs_i, subset_name] for subset_name in subsets.keys()])        # Same colors for all plots        #     max_util = np.max([u for u in util_dict_trans_trunc_sets.values()])        #     min_util = np.min([u for u in util_dict_trans_trunc_sets.values()])        #     if i == 0:        #         print(max_util)        #         print(np.exp(max_util))        #     min_util = np.exp(min_util)        #     max_util = np.exp(max_util)        # Each plot has own colors        max_util = None        min_util = None        for j, subset_name in enumerate(subsets):            # Same colors within columns            #             max_util = np.max([util_dict_trans_trunc_sets[nucleon, o, subset_name] for o in observables_unique])            #             min_util = np.min([util_dict_trans_trunc_sets[nucleon, o, subset_name] for o in observables_unique])            #             min_util = np.exp(min_util)            #             max_util = np.exp(max_util)            ax = axes[i, j]            util_i = util_dict[nucleon, obs_i, subset_name]            #             util_i = np.exp(util_i)            levels = None            #             levels = np.linspace(np.floor(min_util), max_util, 11)            if i == 0:                pass            #                 print(subset_name, min_util, max_util, levels)            #         print(levels)            ax.contourf(                omega, degrees, util_i.reshape(n_omega, n_degrees).T,                vmin=min_util, vmax=max_util,                #                 locator=ticker.LogLocator(),                #             levels=np.log(np.arange(1, max_util+0.25, 0.25)),                #             levels=np.arange(1, max_util+0.25, 0.25),                levels=levels            )            text = obs_i            if obs_i == 'crosssection':                text = 'dsg'            ax.text(                0.05, 0.95, text, transform=ax.transAxes,                bbox=dict(facecolor='w', boxstyle='round', alpha=0.7), ha='left', va='top')            if i == len(observables) - 1:                ax.set_xlabel(fr'$\omega_{{\rm lab}}$ [MeV] ({subset_name})')            if j == 0:                ax.set_ylabel(r'$\theta_{\rm lab}$ [deg]')            # ax.tick_params(direction='in')            set_my_default_ticks(ax)            if i == 0:                ax.set_title(subset_name)    return fig, axesdef plot_allowed_experimental_region(omega, degrees, degrees_min=None, degrees_max=None, omega_min=None, ax=None):    if ax is None:        ax = plt.gca()    # fill_kwargs = dict(facecolor='none', edgecolor='grey', hatch='x', linewidth=0.0)    fill_kwargs = dict(facecolor='none', edgecolor='grey', linewidth=0.0)    if degrees_min is not None:        ax.fill_between([np.min(omega), np.max(omega)], [np.min(degrees), np.min(degrees)],                        [degrees_min, degrees_min], **fill_kwargs)        ax.plot([omega_min or np.min(omega), np.max(omega)], [degrees_min, degrees_min], color='gray', lw=0.5)    if degrees_max is not None:        ax.fill_between([np.min(omega), np.max(omega)], [np.max(degrees), np.max(degrees)],                        [degrees_max, degrees_max], **fill_kwargs)        ax.plot([omega_min or np.min(omega), np.max(omega)], [degrees_max, degrees_max], color='gray', lw=0.5)    if omega_min is not None:        d_max = degrees_max if degrees_max is not None else np.max(degrees)        d_min = degrees_min if degrees_min is not None else np.min(degrees)        ax.fill_between([np.min(omega), omega_min], [d_max, d_max],                        [d_min, d_min], **fill_kwargs)        ax.plot([omega_min, omega_min], [degrees_min or np.min(degrees), degrees_max or np.max(degrees)],                color='gray', lw=0.5)    ax.axvline(omega_lab_cusp, 0, 1, c='grey', lw=0.4, zorder=2)    return axdef plot_observables_true_vs_linearized(        obs_dict, params, nucleon, omega, degrees, observables=None, order=4,        axes=None, offset=0, **kwargs        ):    from matplotlib.collections import LineCollection    observables_all, nucleons_all, orders_all, type_all = tuple(zip(*obs_dict.keys()))    nucleons = np.unique(nucleons_all)    # subsets = np.unique(subsets_all)    if observables is None:        observables = np.unique(observables_all)    if nucleon not in nucleons:        raise ValueError('nucleon must be in dict keys')    # if subset not in subsets:    #     raise ValueError('subset must be in dict keys')    ncols = 6    nrows = int(np.ceil(len(observables) / ncols))    if axes is None:        fig, axes = plt.subplots(nrows, ncols, figsize=(TWO_COLUMN_WIDTH, 2.77), sharex=True, sharey=True)    for i, obs in enumerate(observables):        ax = axes.ravel()[i]        compton_obs_true = obs_dict[obs, nucleon, order, 'nonlinear']        compton_obs_line = obs_dict[obs, nucleon, order, 'linear']        mask = np.isin(compton_obs_true.omega_lab, omega) & np.isin(compton_obs_true.degrees_lab, degrees)        obs_true = np.array([compton_obs_true(p_i)[mask] for p_i in params]).ravel()        obs_line = np.array([compton_obs_line(p_i)[mask] for p_i in params]).ravel()        is_dsg = obs == dsg_label        if is_dsg:            if offset == 0:                offset = 1            obs_true *= offset            ax.loglog(obs_line, obs_true, ls='', marker='o', markersize=0.1, fillstyle='none', **kwargs)        else:            obs_true -= offset            ax.plot(obs_line, obs_true, ls='', marker='o', markersize=0.1, fillstyle='none', **kwargs)        if is_dsg:            obs_magnitude = np.max([np.abs(obs_true), np.abs(obs_line)])            obs_min = np.min([obs_true, obs_line])            bound = 1.5 * obs_magnitude            l_bound = 0.5 * obs_min            ax.set_xlim([l_bound, bound])            ax.set_ylim([l_bound, bound])            col = LineCollection(                [np.array([[1e-7*l_bound, 1e7*bound], [1e-7 * l_bound * offset, 1e7 * bound * offset]]).T],                colors='lightgray'            )        else:            bound = 1.2            ax.set_xticks([-1, 0, 1])            ax.set_yticks([-1, 0, 1])            ax.set_xlim([-bound, bound])            ax.set_ylim([-bound, bound])            col = LineCollection([np.array([[-bound, bound], [-bound-offset, bound-offset]]).T], colors='lightgray')        ax.add_collection(col, autolim=False)        ax.tick_params(direction='in', axis='both', which='both', bottom=True, top=False, left=True, right=False)        ax.set_aspect('equal')        text = obs        if is_dsg:            ax.text(                0.08, 0.92, text, transform=ax.transAxes,                bbox=dict(facecolor='w', boxstyle='round', alpha=0.7), ha='left', va='top')        else:            ax.text(                0.1, 0.9, text, transform=ax.transAxes,                bbox=dict(facecolor='w', boxstyle='round', alpha=0.7), ha='left', va='top')        if i >= (nrows - 1) * ncols:            if is_dsg:                ax.set_xlabel(fr'Linearized [nb/sr]')            else:                ax.set_xlabel(fr'Linearized')        if i % ncols == 0:            if is_dsg:                ax.set_ylabel(r'Exact [nb/sr]')            else:                ax.set_ylabel(r'Exact')    fig = plt.gcf()    fig.tight_layout(h_pad=0.3, w_pad=0.3)    return fig, axesdef plot_utilities_all_observables(        util_dict, nucleon, subset, omega, degrees, observables=None, max_util_dict=None,        degrees_min=None, degrees_max=None, omega_min=None, axes=None, cax=None, vmax=None, vmin=None, **kwargs        ):    nucleons_all, observables_all, subsets_all = tuple(zip(*util_dict.keys()))    nucleons = np.unique(nucleons_all)    subsets = np.unique(subsets_all)    if observables is None:        observables = np.unique(observables_all)    if nucleon not in nucleons:        raise ValueError('nucleon must be in dict keys')    if subset not in subsets:        raise ValueError('subset must be in dict keys')    n_omega = len(omega)    n_degrees = len(degrees)    if vmin is None:        vmin = 0    if vmax is None:        utils = []        for obs in observables:            utils.append(util_dict[nucleon, obs, subset])        vmax = compute_vmax(*utils)    ncols = 4    nrows = int(np.ceil(len(observables) / ncols))    if axes is None:        # fig, axes = plt.subplots(nrows, ncols, figsize=(7, 3.5), sharex=True, sharey=True)        fig = plt.figure(figsize=(TWO_COLUMN_WIDTH, 3.5))        # This gets tight_layout to play nicely with AxesGrid somehow...        # fig, ax_old = plt.subplots(figsize=(TWO_COLUMN_WIDTH, 8), constrained_layout=True)        # ax_old.remove()        grid = AxesGrid(            fig, 111, nrows_ncols=(nrows, ncols), cbar_mode='single',            cbar_location='right', cbar_pad=0.03, cbar_size=CBAR_SIZE, share_all=True,            aspect=False, axes_pad=0.03,        )        axes = np.asarray(grid.axes_row)        if cax is not None:            raise ValueError('If axes is None then cax must also be none')        cax = grid.cbar_axes[0]    for i, obs in enumerate(observables):        ax = axes.ravel()[i]        util_i = util_dict[nucleon, obs, subset]        levels = None        individual_utility_plot(omega, degrees, util_i, ax=ax, vmax=vmax, vmin=vmin, **kwargs)        # ax.contourf(        #     omega, degrees, util_i.reshape(n_omega, n_degrees).T,        #     # vmin=min_util, vmax=max_util,        #     #                 locator=ticker.LogLocator(),        #     #             levels=np.log(np.arange(1, max_util+0.25, 0.25)),        #     #             levels=np.arange(1, max_util+0.25, 0.25),        #     levels=levels,        #     **kwargs        # )        if max_util_dict is not None:            plot_max_utilities(max_util_dict, nucleon=nucleon, observable=obs, subset=subset, ax=ax)        plot_allowed_experimental_region(            omega, degrees, degrees_min=degrees_min, degrees_max=degrees_max, omega_min=omega_min, ax=ax        )        text = obs        if obs == 'crosssection':            text = 'dsg'        ax.text(            0.05, 0.95, text, transform=ax.transAxes,            bbox=dict(facecolor='w', boxstyle='round', alpha=1), ha='left', va='top')        if i >= (nrows - 1) * ncols:            ax.set_xlabel(r'$\omega_{\rm lab}$ [MeV]')        if i % ncols == 0:            ax.set_ylabel(r'$\theta_{\rm lab}$ [deg]')            # add_patch_with_triangle(text, ax)    for ax in axes.ravel():        set_my_default_ticks(ax, tickcolor=TICK_COLOR)        ax.set_xlim(omega.min(), omega.max())        ax.set_ylim(degrees.min(), degrees.max())        # ax.tick_params(which='both', axis='both', colors='grey', labelcolor='k')    if cax is not None:        turn_ax_to_colorbar(cax, vmax=vmax, cmap=kwargs.get('cmap', DEFAULT_CMAP))    fig = plt.gcf()    # fig.tight_layout(h_pad=0.3, w_pad=0.3)    with warnings.catch_warnings():        warnings.simplefilter("ignore")        fig.tight_layout()    return fig, axesdef plot_comparison_subsets_and_truncation(        util_dict_no_trunc, util_dict_with_trunc, nucleon, observable, omega, degrees, max_util_dict_no_trunc=None,        max_util_dict_with_trunc=None, degrees_min=None, degrees_max=None, omega_min=None, axes=None,        subsets=None, add_titles=True, cax=None, vmax=None, vmin=None, **kwargs):    nucleons_all, observables_all, subsets_all = tuple(zip(*util_dict_no_trunc.keys()))    nucleons = np.unique(nucleons_all)    if subsets is None:        subsets = np.unique(subsets_all)    observables = np.unique(observables_all)    n_omega = len(omega)    n_degrees = len(degrees)    if nucleon not in nucleons:        raise ValueError('nucleon must be in dict keys')    if observable not in observables:        raise ValueError('observable must be in dict keys')    if vmin is None:        vmin = 0    if vmax is None:        utils = []        for subset in subsets:            utils.append(util_dict_no_trunc[nucleon, observable, subset])            utils.append(util_dict_with_trunc[nucleon, observable, subset])        vmax = compute_vmax(*utils)    nrows = 2    ncols = len(subsets)    if axes is None:        # fig, axes = plt.subplots(nrows, ncols, figsize=(7, 3), sharex=True, sharey=True)        # fig = plt.figure(figsize=(TWO_COLUMN_WIDTH, 3))        fig, ax_old = plt.subplots(figsize=(TWO_COLUMN_WIDTH, 3), constrained_layout=True)        ax_old.remove()        grid = AxesGrid(            fig, 111, nrows_ncols=(nrows, ncols), cbar_mode='single',            cbar_location='right', cbar_pad=0.03, cbar_size=CBAR_SIZE, share_all=True,            aspect=False, axes_pad=0.03,        )        axes = np.asarray(grid.axes_row)        if cax is not None:            raise ValueError('If axes is None then cax must also be none')        cax = grid.cbar_axes[0]    for i, subset in enumerate(subsets):        ax = axes[0, i]        ax_trunc = axes[1, i]        util_no_trunc = util_dict_no_trunc[nucleon, observable, subset]        util_with_trunc = util_dict_with_trunc[nucleon, observable, subset]        individual_utility_plot(omega, degrees, util_no_trunc, ax=ax, vmax=vmax, vmin=vmin, **kwargs)        individual_utility_plot(omega, degrees, util_with_trunc, ax=ax_trunc, vmax=vmax, vmin=vmin, **kwargs)        # ax.contourf(        #     omega, degrees, util_no_trunc.reshape(n_omega, n_degrees).T,        #     **kwargs        # )        # ax_trunc.contourf(        #     omega, degrees, util_with_trunc.reshape(n_omega, n_degrees).T,        #     **kwargs        # )        if max_util_dict_no_trunc is not None:            plot_max_utilities(                max_util_dict_no_trunc, nucleon=nucleon, observable=observable,                subset=subset, ax=ax            )        if max_util_dict_with_trunc is not None:            plot_max_utilities(                max_util_dict_with_trunc, nucleon=nucleon, observable=observable,                subset=subset, ax=ax_trunc            )        plot_allowed_experimental_region(                omega, degrees, degrees_min=degrees_min, degrees_max=degrees_max, omega_min=omega_min, ax=ax        )        plot_allowed_experimental_region(            omega, degrees, degrees_min=degrees_min, degrees_max=degrees_max, omega_min=omega_min, ax=ax_trunc        )        # ax.text(        #     0.05, 0.95, observable, transform=ax.transAxes,        #     bbox=dict(facecolor='w', boxstyle='round', alpha=1), ha='left', va='top'        # )        # ax_trunc.text(        #     0.05, 0.95, observable, transform=ax_trunc.transAxes,        #     bbox=dict(facecolor='w', boxstyle='round', alpha=1), ha='left', va='top'        # )        # text_no_trunc = r'$\xcancel{\delta y}$'        text_no_trunc = r'$\delta y_{\rm th}$'        text_with_trunc = r'$\delta y_{\rm th}$'        # ax.text(        #     0.95, 0.05, text_no_trunc, transform=ax.transAxes,        #     bbox=dict(facecolor='w', boxstyle='round', alpha=1, hatch='xxx', edgecolor='r'), ha='right', va='bottom'        # )        # ax_trunc.text(        #     0.95, 0.05, text_with_trunc, transform=ax_trunc.transAxes,        #     bbox=dict(facecolor='w', boxstyle='round', alpha=1, edgecolor='g'), ha='right', va='bottom'        # )        ax_trunc.set_xlabel(r'$\omega_{\rm lab}$ [MeV]')        if i % ncols == 0:            ax.set_ylabel(r'$\theta_{\rm lab}$ [deg]')            ax_trunc.set_ylabel(r'$\theta_{\rm lab}$ [deg]')            add_patch_with_triangle(observable, ax)            add_patch_with_triangle(observable, ax_trunc)            add_patch_with_triangle(                text_no_trunc, ax, bbox=dict(facecolor='w', boxstyle='round', alpha=1, hatch='//', edgecolor='r'),                y=0.1            )            add_patch_with_triangle(                text_with_trunc, ax_trunc, bbox=dict(facecolor='w', boxstyle='round', alpha=1, edgecolor='g'),                y=0.1            )        if add_titles:            ax.set_title(subset)    for ax in axes.ravel():        set_my_default_ticks(ax, tickcolor=TICK_COLOR)        ax.set_xlim(omega.min(), omega.max())        ax.set_ylim(degrees.min(), degrees.max())        # ax.tick_params(which='both', axis='both', colors='grey', labelcolor='k')    cmap = kwargs.get('cmap', DEFAULT_CMAP)    if cax is not None:        if add_titles:            turn_ax_to_colorbar(cax, vmax=vmax, cmap=cmap)        else:            turn_ax_to_colorbar(cax, vmax=vmax, cmap=cmap, label=None)    fig = plt.gcf()    # fig.tight_layout(h_pad=0.3, w_pad=0.3)    with warnings.catch_warnings():        warnings.simplefilter("ignore")        fig.tight_layout()    return fig, axesdef plot_comparison_subsets_for_observables(        util_dict, omega, degrees, max_util_dict=None,        degrees_min=None, degrees_max=None, omega_min=None, axes=None,        subsets=None, observables=None, cmap_p=None, cmap_n=None, nucleons=None, cax=None,        figsize=None, aspect=1.05,        vmax=None, vmin=None, **kwargs):    nucleons_all, observables_all, subsets_all = tuple(zip(*util_dict.keys()))    if nucleons is None:        nucleons = np.unique(nucleons_all)    if subsets is None:        subsets = np.unique(subsets_all)    if observables is None:        observables = np.unique(observables_all)    n_omega = len(omega)    n_degrees = len(degrees)    if vmin is None:        vmin = 0    if vmax is None:        utils = []        from itertools import product        for obs, subset, nucleon in product(observables, subsets, nucleons):            utils.append(util_dict[nucleon, obs, subset])        vmax = compute_vmax(*utils)    nrows = len(observables)    ncols = len(nucleons)*len(subsets)    if axes is None:        # fig, axes = plt.subplots(nrows, ncols, figsize=(7, 8), sharex=True, sharey=True)        aspect = abs((omega.max()-omega.min()) / (degrees.min()-degrees.max())) * aspect        # aspect = False        if figsize is None:            figsize = (TWO_COLUMN_WIDTH, 8)        # fig = plt.figure(figsize=(TWO_COLUMN_WIDTH, 8))        # This gets tight_layout to play nicely with AxesGrid somehow...        fig, ax_old = plt.subplots(figsize=figsize, constrained_layout=True)        ax_old.remove()        grid = AxesGrid(            fig, 111, nrows_ncols=(nrows, ncols), cbar_mode='single',            cbar_location='right', cbar_pad=0.03, cbar_size=CBAR_SIZE, share_all=True,            aspect=aspect, axes_pad=0.03,        )        axes = np.asarray(grid.axes_row)        if cax is not None:            raise ValueError('If axes is None then cax must also be none')        cax = grid.cbar_axes[0]    util_i_max = 0    im_max = None    ax_max = None    cmap = DEFAULT_CMAP    for i, obs in enumerate(observables):        for j, subset in enumerate(subsets):            for n, nucleon in enumerate(nucleons):                ax = axes[i, j+3*n]                # ax = axes[i*len(subsets)+j]                util_i = util_dict[nucleon, obs, subset]                cmap = plt.get_cmap(cmap_p if nucleon == 'proton' else cmap_n)                individual_utility_plot(omega, degrees, util_i, ax=ax, cmap=cmap, vmax=vmax, vmin=vmin, **kwargs)                if max_util_dict is not None:                    plot_max_utilities(max_util_dict, nucleon=nucleon, observable=obs, subset=subset, ax=ax)                plot_allowed_experimental_region(                    omega, degrees, degrees_min=degrees_min, degrees_max=degrees_max, omega_min=omega_min, ax=ax                )                text = obs                if obs == 'crosssection':                    text = 'dsg'                # ax.text(                #     0.05, 0.95, text, transform=ax.transAxes,                #     bbox=dict(facecolor='w', boxstyle='round', alpha=0.7), ha='left', va='top')                if i == 0:                    ax.set_title(subset)                if i >= (nrows - 1):                    ax.set_xlabel(r'$\omega_{\rm lab}$ [MeV]')                if j+3*n == 0:                    ax.set_ylabel(r'$\theta_{\rm lab}$ [deg]')                    add_patch_with_triangle(text, ax)                ax.set_xlim(omega.min(), omega.max())                ax.set_ylim(degrees.min(), degrees.max())    for ax in axes.ravel():        set_my_default_ticks(ax, tickcolor=TICK_COLOR)    if cax is not None:        turn_ax_to_colorbar(cax, vmax=vmax, cmap=cmap)    fig = plt.gcf()    # fig.tight_layout(h_pad=0.3, w_pad=0.28)    with warnings.catch_warnings():        warnings.simplefilter("ignore")        fig.tight_layout()    return fig, axesdef individual_utility_plot(omega, degrees, util, ax=None, cmap='gist_stern', **kwargs):    if ax is None:        ax = plt.gca()    n_omega = len(omega)    n_degrees = len(degrees)    util_mat = util.reshape(n_omega, n_degrees).T    import matplotlib.colors as colors    if isinstance(cmap, str):        cmap = plt.get_cmap(cmap)    def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=100):        new_cmap = colors.LinearSegmentedColormap.from_list(            'trunc({n},{a:.2f},{b:.2f})'.format(n=cmap.name, a=minval, b=maxval),            cmap(np.linspace(minval, maxval, n)))        return new_cmap    cmap_trunc = truncate_colormap(cmap, 0.)    from scipy import ndimage    util_mat_zoom = ndimage.zoom(util_mat, 3)    omega_zoom = ndimage.zoom(omega, 3)    degrees_zoom = ndimage.zoom(degrees, 3)    # ax.contourf(    #     omega_zoom, degrees_zoom, util_i_mat_zoom,    #     cmap=cmap,    #     **kwargs    # )    # ax.contourf(    #     omega, degrees, util_i_mat,    #     cmap=cmap,    #     **kwargs    # )    # ax.imshow(    #     util_i_mat, cmap=cmap,    #     origin='lower', aspect='auto', interpolation='gaussian',    #     extent=[omega.min(), omega.max(), degrees.min(), degrees.max()],    #     **kwargs    # )    # ax.pcolormesh(omega, degrees, util_i_mat, cmap=cmap, shading='gouraud', **kwargs)    ax.pcolormesh(omega_zoom, degrees_zoom, util_mat_zoom, cmap=cmap, shading='gouraud', **kwargs)    # im = ax.imshow(    #     omega, degrees, util_i_mat,    #     cmap=cmap,    #     **kwargs    # )    # if util_i.max() > util_i_max:    #     util_i_max = util_i.max()    #     im_max = im    #     ax_max = ax    vmax_contour = kwargs.get('vmax', None)    levels_contour = None    if vmax_contour is not None:        util_mat_max = util_mat.max()        # if util_mat_max < vmax_contour:        #     # vmax_contour = vmax_contour / ((vmax_contour + util_mat_max) / util_mat_max)        #     vmax_contour = 1.3 * util_mat_max        if 0.05 * vmax_contour < util_mat_max < vmax_contour:            vmax_contour = vmax_contour        elif util_mat_max > vmax_contour:            # levels_contour = [vmax_contour + i for i in np.linspace(0, util_mat_max - vmax_contour, 5)]            # Place levels at 50% increments of colorbar shading            fraction = 0.5            # if (1 + fraction) * vmax_contour < util_mat_max:            #     levels_contour = np.arange((1 + fraction) * vmax_contour, util_mat_max, fraction * vmax_contour)            # else:            #     levels_contour = None            levels_contour = np.arange(vmax_contour, util_mat_max, fraction * vmax_contour)            vmax_contour = None            # print(levels_contour)        else:            vmax_contour = None    ax.contour(        omega, degrees, util_mat,        # colors='k',        cmap=cmap_trunc,        linewidths=0.3,        # levels=7,        zorder=1,        vmin=0,        vmax=vmax_contour,        levels=levels_contour,        # vmin=util_i_mat.min(),        # vmin=1e-10,        # vmax=np.average(util_i_mat),        # locator=ticker.LogitLocator(nbins=5),  # nbins requires matplotlib==3.2.0rc1        # locator=ticker.LogLocator(base=0.5, numticks=7),        # locator=LogitLinearLocator(nbins=50),        # extend='both',        # **kwargs    )    # ax.contour(    #     omega_zoom, degrees_zoom, util_i_mat_zoom,    #     # colors='k',    #     cmap=cmap_trunc,    #     linewidths=0.5,    #     levels=10,    #     zorder=1,    #     # vmin=util_i_mat.min(),    #     # vmin=1e-10,    #     # vmax=np.average(util_i_mat),    #     # locator=ticker.LogitLocator(nbins=5),  # nbins requires matplotlib==3.2.0rc1    #     # locator=ticker.LogLocator(base=0.5, numticks=7),    #     # locator=LogitLinearLocator(nbins=50),    #     # extend='both',    #     # **kwargs    # )    return axdef plot_max_utilities(max_util_dict, nucleon, observable, subset, ax=None):    if ax is None:        ax = plt.gca()    max_utils = max_util_dict[nucleon, observable, subset]    max_omega = max_utils['omega']    max_degrees = max_utils['theta']    ax.plot(        max_omega, max_degrees, ls='', marker='o',        # c='k', fillstyle='none',        # markeredgecolor='white', markerfacecolor='k',        markeredgecolor='k', markerfacecolor='w',        markersize=4, markeredgewidth=0.6, zorder=2.5    )    return axdef turn_ax_to_colorbar(ax, vmax, cmap=None, label=r'$U_{\rm KL}$'):    # vmin = kwargs.get('vmin', None)    # vmax = kwargs.get('vmax', None)    # extend = kwargs.get('extend', 'neither')    if cmap is None:        cmap = DEFAULT_CMAP    if isinstance(cmap, str):        cmap = plt.get_cmap(cmap)    extend = 'max'    # norm = mpl.colors.Normalize(vmin=0.1, vmax=0.5)    norm = None    # vmax = 0.77    # print(vmin, vmax)    mpl.colorbar.ColorbarBase(        ax, cmap=cmap, norm=norm, extend=extend, ticks=[0, 1],    )    ax.set_yticklabels(['0', fr'{vmax:0.2f}'.rstrip('0')])  # vertically oriented colorbar    ax.tick_params(width=0, pad=2)    # ax.plot([0, 1], [1, 1], c=cmap(0.85), lw=0.9)    if label is not None:        ax.set_title(label, fontdict=dict(horizontalalignment='left'), loc='left', pad=4)        # plt.title()def add_patch_with_triangle(text, ax=None, y=0.9, bbox=None):    from matplotlib.patches import Polygon    if bbox is None:        bbox = dict(facecolor='w', boxstyle='round', alpha=1)    if ax is None:        ax = plt.gca()    t = ax.annotate(        text, xy=(0, y), xycoords='axes fraction',        xytext=(-10.8, 0), textcoords='offset points',        bbox=bbox,        ha='right', va='center',        arrowprops=dict(arrowstyle='-|>', lw=0, facecolor='k', mutation_scale=11)    )    # t = ax.text(    #     x, y, text, transform=ax.transAxes,    #     bbox=bbox, ha='right', va=va)    # tri_left = 0.6 * x    # tri_right = 0.15 * x    # if va == 'top':    #     tri_top = y    #     tri_bottom = y - 0.1    # if va == 'bottom':    #     tri_bottom = y    #     tri_top = y + 0.1    # if va == 'center':    #     tri_bottom = y - 0.05    #     tri_top = y + 0.05    # tri = Polygon(    #     [[tri_left, tri_bottom], [tri_left, tri_top],    #      [tri_right, (tri_top + tri_bottom) / 2]],    #     closed=True, fill=True, clip_on=False,    #     transform=ax.transAxes, facecolor='k', edgecolor='w', linewidth=0.4)    # ax.add_patch(tri)from matplotlib import tickerfrom matplotlib.ticker import MaxNLocatorimport mathclass LogitLinearLocator(ticker.LogitLocator):    """    Determine the tick locations for logit axes    """    #    # def __init__(self, minor=False, *, nbins="auto"):    #     """    #     Place ticks on the logit locations    #     Parameters    #     ----------    #     nbins : int or 'auto', optional    #         Number of ticks. Only used if minor is False.    #     minor : bool, default: False    #         Indicate if this locator is for minor ticks or not.    #     """    #    #     self._minor = minor    #     MaxNLocator.__init__(self, nbins=nbins, steps=[1, 2, 5, 10])    #    # def set_params(self, minor=None, **kwargs):    #     """Set parameters within this locator."""    #     if minor is not None:    #         self._minor = minor    #     MaxNLocator.set_params(self, **kwargs)    #    # @property    # def minor(self):    #     return self._minor    #    # @minor.setter    # def minor(self, value):    #     self.set_params(minor=value)    def tick_values(self, vmin, vmax):        # dummy axis has no axes attribute        if hasattr(self.axis, "axes") and self.axis.axes.name == "polar":            raise NotImplementedError("Polar axis cannot be logit scaled yet")        if self._nbins == "auto":            if self.axis is not None:                nbins = self.axis.get_tick_space()                if nbins < 2:                    nbins = 2            else:                nbins = 9        else:            nbins = self._nbins        # We define ideal ticks with their index:        # linscale: ... 1e-3 1e-2 1e-1 1/2 1-1e-1 1-1e-2 1-1e-3 ...        # b-scale : ... -3   -2   -1   0   1      2      3      ...        def ideal_ticks(x):            return 10 ** x if x < 0 else np.sqrt(x) if x > 0 else 1 / 2        vmin, vmax = self.nonsingular(vmin, vmax)        binf = int(            np.floor(np.log10(vmin))            if vmin < 0.5            else 0            if vmin < 0.9            else -np.ceil(np.log10(1 - vmin))        )        bsup = int(            np.ceil(np.log10(vmax))            if vmax <= 0.5            else 1            if vmax <= 0.9            else -np.floor(np.log10(1 - vmax))        )        numideal = bsup - binf - 1        if numideal >= 2:            # have 2 or more wanted ideal ticks, so use them as major ticks            if numideal > nbins:                # to many ideal ticks, subsampling ideals for major ticks, and                # take others for minor ticks                subsampling_factor = math.ceil(numideal / nbins)                if self._minor:                    ticklocs = [                        ideal_ticks(b)                        for b in range(binf, bsup + 1)                        if (b % subsampling_factor) != 0                    ]                else:                    ticklocs = [                        ideal_ticks(b)                        for b in range(binf, bsup + 1)                        if (b % subsampling_factor) == 0                    ]                return self.raise_if_exceeds(np.array(ticklocs))            if self._minor:                ticklocs = []                for b in range(binf, bsup):                    if b < -1:                        ticklocs.extend(np.arange(2, 10) * 10 ** b)                    elif b == -1:                        ticklocs.extend(np.arange(2, 5) / 10)                    elif b == 0:                        ticklocs.extend(np.arange(6, 9) / 10)                    else:                        ticklocs.extend(                            1 - np.arange(2, 10)[::-1] * 10 ** (-b - 1)                        )                return self.raise_if_exceeds(np.array(ticklocs))            ticklocs = [ideal_ticks(b) for b in range(binf, bsup + 1)]            return self.raise_if_exceeds(np.array(ticklocs))        # the scale is zoomed so same ticks as linear scale can be used        if self._minor:            return []        return MaxNLocator.tick_values(self, vmin, vmax)    #    # def nonsingular(self, vmin, vmax):    #     standard_minpos = 1e-7    #     initial_range = (standard_minpos, 1 - standard_minpos)    #     if vmin > vmax:    #         vmin, vmax = vmax, vmin    #     if not np.isfinite(vmin) or not np.isfinite(vmax):    #         vmin, vmax = initial_range  # Initial range, no data plotted yet.    #     elif vmax <= 0 or vmin >= 1:    #         # vmax <= 0 occurs when all values are negative    #         # vmin >= 1 occurs when all values are greater than one    #         cbook._warn_external(    #             "Data has no values between 0 and 1, and therefore cannot be "    #             "logit-scaled."    #         )    #         vmin, vmax = initial_range    #     else:    #         minpos = (    #             self.axis.get_minpos()    #             if self.axis is not None    #             else standard_minpos    #         )    #         if not np.isfinite(minpos):    #             minpos = standard_minpos  # This should never take effect.    #         if vmin <= 0:    #             vmin = minpos    #         # NOTE: for vmax, we should query a property similar to get_minpos,    #         # but related to the maximal, less-than-one data point.    #         # Unfortunately, Bbox._minpos is defined very deep in the BBox and    #         # updated with data, so for now we use 1 - minpos as a substitute.    #         if vmax >= 1:    #             vmax = 1 - minpos    #         if vmin == vmax:    #             vmin, vmax = 0.1 * vmin, 1 - 0.1 * vmin    #    #     return vmin, vmaxdef lighten_color(color, amount=0.5):    """    Lightens the given color by multiplying (1-luminosity) by the given amount.    Input can be matplotlib color string, hex string, or RGB tuple.    Examples:    >> lighten_color('g', 0.3)    >> lighten_color('#F034A3', 0.6)    >> lighten_color((.3,.55,.1), 0.5)    """    import matplotlib.colors as mc    import colorsys    try:        c = mc.cnames[color]    except:        c = color    c = colorsys.rgb_to_hls(*mc.to_rgb(c))    return colorsys.hls_to_rgb(c[0], 1 - amount * (1 - c[1]), c[2])def darken_color(color, amount=0.5):    """    Darken the given color by multiplying (1-luminosity) by the given amount.    Input can be matplotlib color string, hex string, or RGB tuple.    Examples:    >> darken_color('g', 0.3)    >> darken_color('#F034A3', 0.6)    >> darken_color((.3,.55,.1), 0.5)    """    return lighten_color(color, 1./amount)import matplotlib.cmfrom matplotlib.colors import ListedColormap, LinearSegmentedColormapturbo_colormap_data = [[0.18995,0.07176,0.23217],[0.19483,0.08339,0.26149],[0.19956,0.09498,0.29024],[0.20415,0.10652,0.31844],[0.20860,0.11802,0.34607],[0.21291,0.12947,0.37314],[0.21708,0.14087,0.39964],[0.22111,0.15223,0.42558],[0.22500,0.16354,0.45096],[0.22875,0.17481,0.47578],[0.23236,0.18603,0.50004],[0.23582,0.19720,0.52373],[0.23915,0.20833,0.54686],[0.24234,0.21941,0.56942],[0.24539,0.23044,0.59142],[0.24830,0.24143,0.61286],[0.25107,0.25237,0.63374],[0.25369,0.26327,0.65406],[0.25618,0.27412,0.67381],[0.25853,0.28492,0.69300],[0.26074,0.29568,0.71162],[0.26280,0.30639,0.72968],[0.26473,0.31706,0.74718],[0.26652,0.32768,0.76412],[0.26816,0.33825,0.78050],[0.26967,0.34878,0.79631],[0.27103,0.35926,0.81156],[0.27226,0.36970,0.82624],[0.27334,0.38008,0.84037],[0.27429,0.39043,0.85393],[0.27509,0.40072,0.86692],[0.27576,0.41097,0.87936],[0.27628,0.42118,0.89123],[0.27667,0.43134,0.90254],[0.27691,0.44145,0.91328],[0.27701,0.45152,0.92347],[0.27698,0.46153,0.93309],[0.27680,0.47151,0.94214],[0.27648,0.48144,0.95064],[0.27603,0.49132,0.95857],[0.27543,0.50115,0.96594],[0.27469,0.51094,0.97275],[0.27381,0.52069,0.97899],[0.27273,0.53040,0.98461],[0.27106,0.54015,0.98930],[0.26878,0.54995,0.99303],[0.26592,0.55979,0.99583],[0.26252,0.56967,0.99773],[0.25862,0.57958,0.99876],[0.25425,0.58950,0.99896],[0.24946,0.59943,0.99835],[0.24427,0.60937,0.99697],[0.23874,0.61931,0.99485],[0.23288,0.62923,0.99202],[0.22676,0.63913,0.98851],[0.22039,0.64901,0.98436],[0.21382,0.65886,0.97959],[0.20708,0.66866,0.97423],[0.20021,0.67842,0.96833],[0.19326,0.68812,0.96190],[0.18625,0.69775,0.95498],[0.17923,0.70732,0.94761],[0.17223,0.71680,0.93981],[0.16529,0.72620,0.93161],[0.15844,0.73551,0.92305],[0.15173,0.74472,0.91416],[0.14519,0.75381,0.90496],[0.13886,0.76279,0.89550],[0.13278,0.77165,0.88580],[0.12698,0.78037,0.87590],[0.12151,0.78896,0.86581],[0.11639,0.79740,0.85559],[0.11167,0.80569,0.84525],[0.10738,0.81381,0.83484],[0.10357,0.82177,0.82437],[0.10026,0.82955,0.81389],[0.09750,0.83714,0.80342],[0.09532,0.84455,0.79299],[0.09377,0.85175,0.78264],[0.09287,0.85875,0.77240],[0.09267,0.86554,0.76230],[0.09320,0.87211,0.75237],[0.09451,0.87844,0.74265],[0.09662,0.88454,0.73316],[0.09958,0.89040,0.72393],[0.10342,0.89600,0.71500],[0.10815,0.90142,0.70599],[0.11374,0.90673,0.69651],[0.12014,0.91193,0.68660],[0.12733,0.91701,0.67627],[0.13526,0.92197,0.66556],[0.14391,0.92680,0.65448],[0.15323,0.93151,0.64308],[0.16319,0.93609,0.63137],[0.17377,0.94053,0.61938],[0.18491,0.94484,0.60713],[0.19659,0.94901,0.59466],[0.20877,0.95304,0.58199],[0.22142,0.95692,0.56914],[0.23449,0.96065,0.55614],[0.24797,0.96423,0.54303],[0.26180,0.96765,0.52981],[0.27597,0.97092,0.51653],[0.29042,0.97403,0.50321],[0.30513,0.97697,0.48987],[0.32006,0.97974,0.47654],[0.33517,0.98234,0.46325],[0.35043,0.98477,0.45002],[0.36581,0.98702,0.43688],[0.38127,0.98909,0.42386],[0.39678,0.99098,0.41098],[0.41229,0.99268,0.39826],[0.42778,0.99419,0.38575],[0.44321,0.99551,0.37345],[0.45854,0.99663,0.36140],[0.47375,0.99755,0.34963],[0.48879,0.99828,0.33816],[0.50362,0.99879,0.32701],[0.51822,0.99910,0.31622],[0.53255,0.99919,0.30581],[0.54658,0.99907,0.29581],[0.56026,0.99873,0.28623],[0.57357,0.99817,0.27712],[0.58646,0.99739,0.26849],[0.59891,0.99638,0.26038],[0.61088,0.99514,0.25280],[0.62233,0.99366,0.24579],[0.63323,0.99195,0.23937],[0.64362,0.98999,0.23356],[0.65394,0.98775,0.22835],[0.66428,0.98524,0.22370],[0.67462,0.98246,0.21960],[0.68494,0.97941,0.21602],[0.69525,0.97610,0.21294],[0.70553,0.97255,0.21032],[0.71577,0.96875,0.20815],[0.72596,0.96470,0.20640],[0.73610,0.96043,0.20504],[0.74617,0.95593,0.20406],[0.75617,0.95121,0.20343],[0.76608,0.94627,0.20311],[0.77591,0.94113,0.20310],[0.78563,0.93579,0.20336],[0.79524,0.93025,0.20386],[0.80473,0.92452,0.20459],[0.81410,0.91861,0.20552],[0.82333,0.91253,0.20663],[0.83241,0.90627,0.20788],[0.84133,0.89986,0.20926],[0.85010,0.89328,0.21074],[0.85868,0.88655,0.21230],[0.86709,0.87968,0.21391],[0.87530,0.87267,0.21555],[0.88331,0.86553,0.21719],[0.89112,0.85826,0.21880],[0.89870,0.85087,0.22038],[0.90605,0.84337,0.22188],[0.91317,0.83576,0.22328],[0.92004,0.82806,0.22456],[0.92666,0.82025,0.22570],[0.93301,0.81236,0.22667],[0.93909,0.80439,0.22744],[0.94489,0.79634,0.22800],[0.95039,0.78823,0.22831],[0.95560,0.78005,0.22836],[0.96049,0.77181,0.22811],[0.96507,0.76352,0.22754],[0.96931,0.75519,0.22663],[0.97323,0.74682,0.22536],[0.97679,0.73842,0.22369],[0.98000,0.73000,0.22161],[0.98289,0.72140,0.21918],[0.98549,0.71250,0.21650],[0.98781,0.70330,0.21358],[0.98986,0.69382,0.21043],[0.99163,0.68408,0.20706],[0.99314,0.67408,0.20348],[0.99438,0.66386,0.19971],[0.99535,0.65341,0.19577],[0.99607,0.64277,0.19165],[0.99654,0.63193,0.18738],[0.99675,0.62093,0.18297],[0.99672,0.60977,0.17842],[0.99644,0.59846,0.17376],[0.99593,0.58703,0.16899],[0.99517,0.57549,0.16412],[0.99419,0.56386,0.15918],[0.99297,0.55214,0.15417],[0.99153,0.54036,0.14910],[0.98987,0.52854,0.14398],[0.98799,0.51667,0.13883],[0.98590,0.50479,0.13367],[0.98360,0.49291,0.12849],[0.98108,0.48104,0.12332],[0.97837,0.46920,0.11817],[0.97545,0.45740,0.11305],[0.97234,0.44565,0.10797],[0.96904,0.43399,0.10294],[0.96555,0.42241,0.09798],[0.96187,0.41093,0.09310],[0.95801,0.39958,0.08831],[0.95398,0.38836,0.08362],[0.94977,0.37729,0.07905],[0.94538,0.36638,0.07461],[0.94084,0.35566,0.07031],[0.93612,0.34513,0.06616],[0.93125,0.33482,0.06218],[0.92623,0.32473,0.05837],[0.92105,0.31489,0.05475],[0.91572,0.30530,0.05134],[0.91024,0.29599,0.04814],[0.90463,0.28696,0.04516],[0.89888,0.27824,0.04243],[0.89298,0.26981,0.03993],[0.88691,0.26152,0.03753],[0.88066,0.25334,0.03521],[0.87422,0.24526,0.03297],[0.86760,0.23730,0.03082],[0.86079,0.22945,0.02875],[0.85380,0.22170,0.02677],[0.84662,0.21407,0.02487],[0.83926,0.20654,0.02305],[0.83172,0.19912,0.02131],[0.82399,0.19182,0.01966],[0.81608,0.18462,0.01809],[0.80799,0.17753,0.01660],[0.79971,0.17055,0.01520],[0.79125,0.16368,0.01387],[0.78260,0.15693,0.01264],[0.77377,0.15028,0.01148],[0.76476,0.14374,0.01041],[0.75556,0.13731,0.00942],[0.74617,0.13098,0.00851],[0.73661,0.12477,0.00769],[0.72686,0.11867,0.00695],[0.71692,0.11268,0.00629],[0.70680,0.10680,0.00571],[0.69650,0.10102,0.00522],[0.68602,0.09536,0.00481],[0.67535,0.08980,0.00449],[0.66449,0.08436,0.00424],[0.65345,0.07902,0.00408],[0.64223,0.07380,0.00401],[0.63082,0.06868,0.00401],[0.61923,0.06367,0.00410],[0.60746,0.05878,0.00427],[0.59550,0.05399,0.00453],[0.58336,0.04931,0.00486],[0.57103,0.04474,0.00529],[0.55852,0.04028,0.00579],[0.54583,0.03593,0.00638],[0.53295,0.03169,0.00705],[0.51989,0.02756,0.00780],[0.50664,0.02354,0.00863],[0.49321,0.01963,0.00955],[0.47960,0.01583,0.01055]]matplotlib.cm.register_cmap('turbo', cmap=ListedColormap(turbo_colormap_data))def create_scaled_turbo():    n_colors = 500    cs = np.linspace(0.2, 1., n_colors)    colors = plt.get_cmap('turbo')(cs)    cmap_inputs = np.linspace(0.15, 1, n_colors) ** 3    cmap_inputs_small = np.linspace(0, 0.15 ** (0.75), n_colors) ** 4    light_colors = [lighten_color(colors[0], ((i + 1e-7) / n_colors) ** 0.1) for i in range(n_colors)]    colors = list(zip(cmap_inputs, colors))    colors = list(zip(cmap_inputs_small, light_colors)) + colors    return matplotlib.colors.LinearSegmentedColormap.from_list('mycmap', colors, N=256)def create_scaled_turbo2():    import seaborn as sns    n_colors = 1000    cs = np.linspace(0.2, 1., n_colors)    colors = plt.get_cmap('turbo')(cs)    cmap_inputs = np.linspace(0.33, 1, n_colors) ** 3    cmap_inputs_small = np.linspace(0, 0.33**3, n_colors)#     light_colors = [lighten_color(colors[0], ((i + 1e-7) / n_colors) ** 0.1) for i in range(n_colors)]    light_colors = sns.light_palette(colors[0], n_colors=n_colors)#     print(light_colors)    colors = list(zip(cmap_inputs, colors))    colors = list(zip(cmap_inputs_small, light_colors)) + colors    return matplotlib.colors.LinearSegmentedColormap.from_list('mycmap', colors, N=256)matplotlib.cm.register_cmap('turbo_scaled', cmap=create_scaled_turbo2())color_moves_dict = {'blue': [(0.0, 0.901961, 0.901961), (0.004987770318984986, 0.670588, 0.670588), (0.009975540637969972, 0.533333, 0.533333), (0.014963310956954955, 0.396078, 0.396078), (0.019951081275939943, 0.294118, 0.294118), (0.024938851594924927, 0.239216, 0.239216), (0.02992662191390991, 0.160784, 0.160784), (0.03491439223289489, 0.113725, 0.113725), (0.03990216255187989, 0.082353, 0.082353), (0.04488993287086487, 0.05098, 0.05098), (0.049877703189849854, 0.082353, 0.082353), (0.05486547350883484, 0.152941, 0.152941), (0.05985324382781982, 0.203922, 0.203922), (0.0648410141468048, 0.243137, 0.243137), (0.06982878446578979, 0.270588, 0.270588), (0.07481655478477478, 0.278431, 0.278431), (0.07980432510375977, 0.278431, 0.278431), (0.08479209542274475, 0.25098, 0.25098), (0.08977986574172973, 0.219608, 0.219608), (0.09476763606071471, 0.180392, 0.180392), (0.09975540637969971, 0.121569, 0.121569), (0.09976540637969972, 0.4, 0.4), (0.11968104887388464, 0.419608, 0.419608), (0.13959669136806951, 0.435294, 0.435294), (0.15951233386225444, 0.45098, 0.45098), (0.17942797635643926, 0.462745, 0.462745), (0.19934361885062418, 0.47451, 0.47451), (0.2192592613448091, 0.486275, 0.486275), (0.23917490383899398, 0.509804, 0.509804), (0.2590905463331789, 0.533333, 0.533333), (0.2790061888273637, 0.552941, 0.552941), (0.2989218313215487, 0.596078, 0.596078), (0.3188374738157336, 0.623529, 0.623529), (0.33875311630991845, 0.658824, 0.658824), (0.35866875880410337, 0.686275, 0.686275), (0.3785844012982883, 0.729412, 0.729412), (0.39850004379247317, 0.756863, 0.756863), (0.41841568628665804, 0.8, 0.8), (0.43833132878084297, 0.835294, 0.835294), (0.45824697127502784, 0.87451, 0.87451), (0.47816261376921276, 0.909804, 0.909804), (0.49807825626339763, 0.94902, 0.94902), (0.49808825626339764, 1.0, 1.0), (0.5181873365804348, 0.980392, 0.980392), (0.538286416897472, 0.94902, 0.94902), (0.5784845775315464, 0.890196, 0.890196), (0.6186827381656207, 0.819608, 0.819608), (0.658880898799695, 0.741176, 0.741176), (0.6990790594337695, 0.658824, 0.658824), (0.7392772200678438, 0.580392, 0.580392), (0.7794753807019181, 0.521569, 0.521569), (0.8196735413359926, 0.478431, 0.478431), (0.8598717019700669, 0.439216, 0.439216), (0.9000698626041412, 0.4, 0.4), (0.9000798626041412, 0.301961, 0.301961), (0.9050758694739341, 0.419608, 0.419608), (0.9100718763437271, 0.501961, 0.501961), (0.9150678832135201, 0.54902, 0.54902), (0.920063890083313, 0.6, 0.6), (0.9250598969531059, 0.639216, 0.639216), (0.9300559038228988, 0.678431, 0.678431), (0.9350519106926918, 0.709804, 0.709804), (0.9400479175624847, 0.729412, 0.729412), (0.9550359381718636, 0.74902, 0.74902), (0.9600319450416565, 0.768627, 0.768627), (0.9650279519114494, 0.788235, 0.788235), (0.9700239587812424, 0.811765, 0.811765), (0.9750199656510353, 0.831373, 0.831373), (0.9800159725208283, 0.85098, 0.85098), (0.9850119793906212, 0.870588, 0.870588), (0.9900079862604141, 0.901961, 0.901961), (0.995003993130207, 0.929412, 0.929412), (0.9980015972520828, 0.960784, 0.960784), (1.0, 0.984314, 0.984314)], 'green': [(0.0, 0.984314, 0.984314), (0.004987770318984986, 0.94902, 0.94902), (0.009975540637969972, 0.921569, 0.921569), (0.014963310956954955, 0.878431, 0.878431), (0.019951081275939943, 0.839216, 0.839216), (0.024938851594924927, 0.8, 0.8), (0.02992662191390991, 0.760784, 0.760784), (0.03491439223289489, 0.721569, 0.721569), (0.03990216255187989, 0.678431, 0.678431), (0.04488993287086487, 0.631373, 0.631373), (0.049877703189849854, 0.588235, 0.588235), (0.05486547350883484, 0.54902, 0.54902), (0.05985324382781982, 0.521569, 0.521569), (0.0648410141468048, 0.490196, 0.490196), (0.06982878446578979, 0.45098, 0.45098), (0.07481655478477478, 0.4, 0.4), (0.07980432510375977, 0.34902, 0.34902), (0.08479209542274475, 0.278431, 0.278431), (0.08977986574172973, 0.231373, 0.231373), (0.09476763606071471, 0.172549, 0.172549), (0.09975540637969971, 0.109804, 0.109804), (0.09976540637969972, 0.396078, 0.396078), (0.11968104887388464, 0.419608, 0.419608), (0.13959669136806951, 0.439216, 0.439216), (0.15951233386225444, 0.458824, 0.458824), (0.17942797635643926, 0.478431, 0.478431), (0.19934361885062418, 0.501961, 0.501961), (0.2192592613448091, 0.521569, 0.521569), (0.23917490383899398, 0.54902, 0.54902), (0.2590905463331789, 0.580392, 0.580392), (0.2790061888273637, 0.611765, 0.611765), (0.2989218313215487, 0.658824, 0.658824), (0.3188374738157336, 0.701961, 0.701961), (0.33875311630991845, 0.741176, 0.741176), (0.35866875880410337, 0.780392, 0.780392), (0.3785844012982883, 0.819608, 0.819608), (0.39850004379247317, 0.85098, 0.85098), (0.41841568628665804, 0.890196, 0.890196), (0.43833132878084297, 0.921569, 0.921569), (0.45824697127502784, 0.94902, 0.94902), (0.47816261376921276, 0.980392, 0.980392), (0.49807825626339763, 1.0, 1.0), (0.49808825626339764, 1.0, 1.0), (0.5181873365804348, 0.937255, 0.937255), (0.538286416897472, 0.894118, 0.894118), (0.5784845775315464, 0.823529, 0.823529), (0.6186827381656207, 0.752941, 0.752941), (0.658880898799695, 0.670588, 0.670588), (0.6990790594337695, 0.6, 0.6), (0.7392772200678438, 0.52549, 0.52549), (0.7794753807019181, 0.47451, 0.47451), (0.8196735413359926, 0.443137, 0.443137), (0.8598717019700669, 0.415686, 0.415686), (0.9000698626041412, 0.392157, 0.392157), (0.9000798626041412, 0.058824, 0.058824), (0.9050758694739341, 0.109804, 0.109804), (0.9100718763437271, 0.113725, 0.113725), (0.9150678832135201, 0.109804, 0.109804), (0.920063890083313, 0.133333, 0.133333), (0.9250598969531059, 0.164706, 0.164706), (0.9300559038228988, 0.211765, 0.211765), (0.9350519106926918, 0.258824, 0.258824), (0.9400479175624847, 0.313725, 0.313725), (0.9550359381718636, 0.364706, 0.364706), (0.9600319450416565, 0.435294, 0.435294), (0.9650279519114494, 0.501961, 0.501961), (0.9700239587812424, 0.576471, 0.576471), (0.9750199656510353, 0.639216, 0.639216), (0.9800159725208283, 0.705882, 0.705882), (0.9850119793906212, 0.776471, 0.776471), (0.9900079862604141, 0.85098, 0.85098), (0.995003993130207, 0.917647, 0.917647), (0.9980015972520828, 0.968627, 0.968627), (1.0, 1.0, 1.0)], 'red': [(0.0, 1.0, 1.0), (0.004987770318984986, 0.960784, 0.960784), (0.009975540637969972, 0.886275, 0.886275), (0.014963310956954955, 0.784314, 0.784314), (0.019951081275939943, 0.666667, 0.666667), (0.024938851594924927, 0.556863, 0.556863), (0.02992662191390991, 0.431373, 0.431373), (0.03491439223289489, 0.317647, 0.317647), (0.03990216255187989, 0.211765, 0.211765), (0.04488993287086487, 0.109804, 0.109804), (0.049877703189849854, 0.082353, 0.082353), (0.05486547350883484, 0.109804, 0.109804), (0.05985324382781982, 0.113725, 0.113725), (0.0648410141468048, 0.117647, 0.117647), (0.06982878446578979, 0.117647, 0.117647), (0.07481655478477478, 0.113725, 0.113725), (0.07980432510375977, 0.109804, 0.109804), (0.08479209542274475, 0.094118, 0.094118), (0.08977986574172973, 0.086275, 0.086275), (0.09476763606071471, 0.07451, 0.07451), (0.09975540637969971, 0.054902, 0.054902), (0.09976540637969972, 0.380392, 0.380392), (0.11968104887388464, 0.388235, 0.388235), (0.13959669136806951, 0.396078, 0.396078), (0.15951233386225444, 0.403922, 0.403922), (0.17942797635643926, 0.411765, 0.411765), (0.19934361885062418, 0.423529, 0.423529), (0.2192592613448091, 0.443137, 0.443137), (0.23917490383899398, 0.466667, 0.466667), (0.2590905463331789, 0.498039, 0.498039), (0.2790061888273637, 0.52549, 0.52549), (0.2989218313215487, 0.572549, 0.572549), (0.3188374738157336, 0.607843, 0.607843), (0.33875311630991845, 0.65098, 0.65098), (0.35866875880410337, 0.686275, 0.686275), (0.3785844012982883, 0.737255, 0.737255), (0.39850004379247317, 0.772549, 0.772549), (0.41841568628665804, 0.823529, 0.823529), (0.43833132878084297, 0.866667, 0.866667), (0.45824697127502784, 0.905882, 0.905882), (0.47816261376921276, 0.945098, 0.945098), (0.49807825626339763, 0.976471, 0.976471), (0.49808825626339764, 1.0, 1.0), (0.5181873365804348, 0.882353, 0.882353), (0.538286416897472, 0.815686, 0.815686), (0.5784845775315464, 0.737255, 0.737255), (0.6186827381656207, 0.670588, 0.670588), (0.658880898799695, 0.6, 0.6), (0.6990790594337695, 0.541176, 0.541176), (0.7392772200678438, 0.482353, 0.482353), (0.7794753807019181, 0.435294, 0.435294), (0.8196735413359926, 0.411765, 0.411765), (0.8598717019700669, 0.396078, 0.396078), (0.9000698626041412, 0.380392, 0.380392), (0.9000798626041412, 0.129412, 0.129412), (0.9050758694739341, 0.164706, 0.164706), (0.9100718763437271, 0.152941, 0.152941), (0.9150678832135201, 0.109804, 0.109804), (0.920063890083313, 0.101961, 0.101961), (0.9250598969531059, 0.090196, 0.090196), (0.9300559038228988, 0.082353, 0.082353), (0.9350519106926918, 0.078431, 0.078431), (0.9400479175624847, 0.086275, 0.086275), (0.9550359381718636, 0.090196, 0.090196), (0.9600319450416565, 0.121569, 0.121569), (0.9650279519114494, 0.172549, 0.172549), (0.9700239587812424, 0.227451, 0.227451), (0.9750199656510353, 0.282353, 0.282353), (0.9800159725208283, 0.341176, 0.341176), (0.9850119793906212, 0.4, 0.4), (0.9900079862604141, 0.478431, 0.478431), (0.995003993130207, 0.556863, 0.556863), (0.9980015972520828, 0.639216, 0.639216), (1.0, 0.8, 0.8)]}matplotlib.cm.register_cmap(    'colormoves_outlier', cmap=LinearSegmentedColormap('colormoves_outlier', color_moves_dict, 256))colormap2 = {'blue': [(0.0, 0.780392, 0.780392), (0.010017573833465576, 0.509804, 0.509804), (0.020035147666931152, 0.360784, 0.360784), (0.03005272150039673, 0.254902, 0.254902), (0.040070295333862305, 0.168627, 0.168627), (0.05008786916732788, 0.109804, 0.109804), (0.06010544300079346, 0.07451, 0.07451), (0.07012301683425903, 0.043137, 0.043137), (0.08014059066772461, 0.027451, 0.027451), (0.09015816450119019, 0.011765, 0.011765), (0.10017573833465576, 0.0, 0.0), (0.10018573833465577, 0.0705882352941176, 0.0705882352941176), (0.11337054137777158, 0.101961, 0.101961), (0.122640974540073, 0.0901961, 0.0901961), (0.13088162670189402, 0.0705882, 0.0705882), (0.14025503796424343, 0.0431373, 0.0431373), (0.15027236287164036, 0.0627451, 0.0627451), (0.1602896877790373, 0.0745098, 0.0745098), (0.17030701268643422, 0.0941176, 0.0941176), (0.1803243375938311, 0.113725, 0.113725), (0.19034166250122803, 0.133333, 0.133333), (0.20035898740862496, 0.145098, 0.145098), (0.21037631231602189, 0.156863, 0.156863), (0.22039363722341881, 0.168627, 0.168627), (0.22750112959171503, 0.196078, 0.196078), (0.23615369415372822, 0.235294, 0.235294), (0.2458360397162218, 0.278431, 0.278431), (0.25242864158427786, 0.321569, 0.321569), (0.2606688930531026, 0.407843, 0.407843), (0.26973337001530784, 0.509804, 0.509804), (0.27859189077741714, 0.643137, 0.643137), (0.2845662233521886, 0.713725, 0.713725), (0.2899226873266719, 0.803921568627451, 0.803921568627451), (0.2965148885017317, 0.905882352941176, 0.905882352941176), (0.30001734598235397, 0.972549019607843, 0.972549019607843), (0.3035194027699799, 0.937255, 0.937255), (0.3076397288508904, 0.925490196078431, 0.925490196078431), (0.3129957921323774, 0.886275, 0.886275), (0.31814629990676463, 0.866667, 0.866667), (0.32597463897539714, 0.843137, 0.843137), (0.3333910656438376, 0.835294, 0.835294), (0.3445159059929963, 0.87451, 0.87451), (0.3517259757683443, 0.862745, 0.862745), (0.35996662793016526, 0.870588, 0.870588), (0.36882514869227456, 0.85098, 0.85098), (0.3795376759482448, 0.831373, 0.831373), (0.39025020320421505, 0.811765, 0.811765), (0.4007054855565634, 0.788235, 0.788235), (0.4107228104639603, 0.768627, 0.768627), (0.4207401353713572, 0.741176, 0.741176), (0.43619085730852625, 0.709804, 0.709804), (0.4487577917513538, 0.678431, 0.678431), (0.4582341811137513, 0.639216, 0.639216), (0.46482678298180735, 0.6, 0.6), (0.4716249403569632, 0.560784, 0.560784), (0.4786294546252114, 0.509804, 0.509804), (0.48872411328089344, 0.45098, 0.45098), (0.5008787346305326, 0.298039215686275, 0.298039215686275), (0.5008887346305326, 0.521569, 0.521569), (0.5507998611674794, 0.568627, 0.568627), (0.6007109877044261, 0.631373, 0.631373), (0.6506221142413728, 0.670588, 0.670588), (0.7005332407783196, 0.709804, 0.709804), (0.7504443673152663, 0.74902, 0.74902), (0.800355493852213, 0.8, 0.8), (0.8502666203891598, 0.85098, 0.85098), (0.9001777469261065, 0.901961, 0.901961), (0.9500888734630533, 0.968627, 0.968627), (1.0, 1.0, 1.0)], 'green': [(0.0, 0.976471, 0.976471), (0.010017573833465576, 0.917647, 0.917647), (0.020035147666931152, 0.831373, 0.831373), (0.03005272150039673, 0.713725, 0.713725), (0.040070295333862305, 0.533333, 0.533333), (0.05008786916732788, 0.376471, 0.376471), (0.06010544300079346, 0.25098, 0.25098), (0.07012301683425903, 0.145098, 0.145098), (0.08014059066772461, 0.07451, 0.07451), (0.09015816450119019, 0.031373, 0.031373), (0.10017573833465576, 0.003922, 0.003922), (0.10018573833465577, 0.0, 0.0), (0.11337054137777158, 0.00392157, 0.00392157), (0.122640974540073, 0.0156863, 0.0156863), (0.13088162670189402, 0.027451, 0.027451), (0.14025503796424343, 0.0627451, 0.0627451), (0.15027236287164036, 0.12549, 0.12549), (0.1602896877790373, 0.184314, 0.184314), (0.17030701268643422, 0.266667, 0.266667), (0.1803243375938311, 0.345098, 0.345098), (0.19034166250122803, 0.411765, 0.411765), (0.20035898740862496, 0.47451, 0.47451), (0.21037631231602189, 0.54902, 0.54902), (0.22039363722341881, 0.619608, 0.619608), (0.22750112959171503, 0.658824, 0.658824), (0.23615369415372822, 0.717647, 0.717647), (0.2458360397162218, 0.776471, 0.776471), (0.25242864158427786, 0.823529, 0.823529), (0.2606688930531026, 0.87451, 0.87451), (0.26973337001530784, 0.917647, 0.917647), (0.27859189077741714, 0.956863, 0.956863), (0.2845662233521886, 0.964706, 0.964706), (0.2899226873266719, 0.972549019607843, 0.972549019607843), (0.2965148885017317, 0.988235294117647, 0.988235294117647), (0.30001734598235397, 1.0, 1.0), (0.3035194027699799, 0.988235, 0.988235), (0.3076397288508904, 0.988235294117647, 0.988235294117647), (0.3129957921323774, 0.980392, 0.980392), (0.31814629990676463, 0.980392, 0.980392), (0.32597463897539714, 0.980392, 0.980392), (0.3333910656438376, 0.964706, 0.964706), (0.3445159059929963, 0.941176, 0.941176), (0.3517259757683443, 0.901961, 0.901961), (0.35996662793016526, 0.854902, 0.854902), (0.36882514869227456, 0.8, 0.8), (0.3795376759482448, 0.709804, 0.709804), (0.39025020320421505, 0.615686, 0.615686), (0.4007054855565634, 0.537255, 0.537255), (0.4107228104639603, 0.466667, 0.466667), (0.4207401353713572, 0.396078, 0.396078), (0.43619085730852625, 0.317647, 0.317647), (0.4487577917513538, 0.243137, 0.243137), (0.4582341811137513, 0.164706, 0.164706), (0.46482678298180735, 0.0980392, 0.0980392), (0.4716249403569632, 0.0392157, 0.0392157), (0.4786294546252114, 0.0509804, 0.0509804), (0.48872411328089344, 0.0235294, 0.0235294), (0.5008787346305326, 0.00392156862745098, 0.00392156862745098), (0.5008887346305326, 0.105882, 0.105882), (0.5507998611674794, 0.133333, 0.133333), (0.6007109877044261, 0.235294, 0.235294), (0.6506221142413728, 0.337255, 0.337255), (0.7005332407783196, 0.427451, 0.427451), (0.7504443673152663, 0.513725, 0.513725), (0.800355493852213, 0.615686, 0.615686), (0.8502666203891598, 0.709804, 0.709804), (0.9001777469261065, 0.811765, 0.811765), (0.9500888734630533, 0.929412, 0.929412), (1.0, 0.996078, 0.996078)], 'red': [(0.0, 1.0, 1.0), (0.010017573833465576, 0.980392, 0.980392), (0.020035147666931152, 0.94902, 0.94902), (0.03005272150039673, 0.909804, 0.909804), (0.040070295333862305, 0.85098, 0.85098), (0.05008786916732788, 0.780392, 0.780392), (0.06010544300079346, 0.670588, 0.670588), (0.07012301683425903, 0.501961, 0.501961), (0.08014059066772461, 0.34902, 0.34902), (0.09015816450119019, 0.239216, 0.239216), (0.10017573833465576, 0.14902, 0.14902), (0.10018573833465577, 0.188235294117647, 0.188235294117647), (0.11337054137777158, 0.4, 0.4), (0.122640974540073, 0.470588, 0.470588), (0.13088162670189402, 0.54902, 0.54902), (0.14025503796424343, 0.619608, 0.619608), (0.15027236287164036, 0.690196, 0.690196), (0.1602896877790373, 0.741176, 0.741176), (0.17030701268643422, 0.788235, 0.788235), (0.1803243375938311, 0.811765, 0.811765), (0.19034166250122803, 0.831373, 0.831373), (0.20035898740862496, 0.85098, 0.85098), (0.21037631231602189, 0.870588, 0.870588), (0.22039363722341881, 0.878431, 0.878431), (0.22750112959171503, 0.890196, 0.890196), (0.23615369415372822, 0.909804, 0.909804), (0.2458360397162218, 0.929412, 0.929412), (0.25242864158427786, 0.94902, 0.94902), (0.2606688930531026, 0.968627, 0.968627), (0.26973337001530784, 0.980392, 0.980392), (0.27859189077741714, 0.988235, 0.988235), (0.2845662233521886, 0.992157, 0.992157), (0.2899226873266719, 0.992156862745098, 0.992156862745098), (0.2965148885017317, 0.988235294117647, 0.988235294117647), (0.30001734598235397, 1.0, 1.0), (0.3035194027699799, 0.913725, 0.913725), (0.3076397288508904, 0.890196078431372, 0.890196078431372), (0.3129957921323774, 0.827451, 0.827451), (0.31814629990676463, 0.764706, 0.764706), (0.32597463897539714, 0.658824, 0.658824), (0.3333910656438376, 0.572549, 0.572549), (0.3445159059929963, 0.423529, 0.423529), (0.3517259757683443, 0.262745, 0.262745), (0.35996662793016526, 0.0705882, 0.0705882), (0.36882514869227456, 0.0509804, 0.0509804), (0.3795376759482448, 0.0235294, 0.0235294), (0.39025020320421505, 0.0313725, 0.0313725), (0.4007054855565634, 0.0313725, 0.0313725), (0.4107228104639603, 0.0392157, 0.0392157), (0.4207401353713572, 0.0509804, 0.0509804), (0.43619085730852625, 0.054902, 0.054902), (0.4487577917513538, 0.054902, 0.054902), (0.4582341811137513, 0.0431373, 0.0431373), (0.46482678298180735, 0.0313725, 0.0313725), (0.4716249403569632, 0.0392157, 0.0392157), (0.4786294546252114, 0.105882, 0.105882), (0.48872411328089344, 0.113725, 0.113725), (0.5008787346305326, 0.0862745098039216, 0.0862745098039216), (0.5008887346305326, 0.137255, 0.137255), (0.5507998611674794, 0.12549, 0.12549), (0.6007109877044261, 0.176471, 0.176471), (0.6506221142413728, 0.227451, 0.227451), (0.7005332407783196, 0.282353, 0.282353), (0.7504443673152663, 0.345098, 0.345098), (0.800355493852213, 0.431373, 0.431373), (0.8502666203891598, 0.509804, 0.509804), (0.9001777469261065, 0.611765, 0.611765), (0.9500888734630533, 0.776471, 0.776471), (1.0, 0.929412, 0.929412)]}colormap3 = {'blue': [(0.0, 0.988235, 0.988235), (0.0004024604558944702, 0.988235, 0.988235), (0.010061511397361757, 0.843137, 0.843137), (0.020123022794723514, 0.741176, 0.741176), (0.030184534192085263, 0.654902, 0.654902), (0.04024604558944703, 0.576471, 0.576471), (0.05030755698680878, 0.486275, 0.486275), (0.06036906838417053, 0.388235, 0.388235), (0.07043057978153228, 0.286275, 0.286275), (0.08049209117889405, 0.219608, 0.219608), (0.0905536025762558, 0.14902, 0.14902), (0.10061511397361755, 0.094118, 0.094118), (0.11067662537097932, 0.054902, 0.054902), (0.12073813676834105, 0.035294, 0.035294), (0.13079964816570283, 0.019608, 0.019608), (0.14086115956306455, 0.0, 0.0), (0.15092267096042633, 0.0, 0.0), (0.1609841823577881, 0.011765, 0.011765), (0.17104569375514983, 0.023529, 0.023529), (0.1811072051525116, 0.031373, 0.031373), (0.19116871654987333, 0.058824, 0.058824), (0.2012302279472351, 0.090196, 0.090196), (0.20124022794723512, 0.176471, 0.176471), (0.226195791128397, 0.2, 0.2), (0.25115135430955887, 0.239216, 0.239216), (0.27610691749072075, 0.266667, 0.266667), (0.3010624806718826, 0.290196, 0.290196), (0.3260180438530445, 0.317647, 0.317647), (0.35097360703420644, 0.345098, 0.345098), (0.37592917021536826, 0.368627, 0.368627), (0.4008847333965302, 0.388235, 0.388235), (0.425840296577692, 0.407843, 0.407843), (0.45079585975885395, 0.427451, 0.427451), (0.4757514229400158, 0.454902, 0.454902), (0.5007069861211777, 0.494118, 0.494118), (0.5256625493023396, 0.52549, 0.52549), (0.5506181124835015, 0.564706, 0.564706), (0.5755736756646633, 0.607843, 0.607843), (0.6005292388458252, 0.658824, 0.658824), (0.6254848020269871, 0.701961, 0.701961), (0.650440365208149, 0.737255, 0.737255), (0.6753959283893108, 0.807843, 0.807843), (0.7003514915704727, 0.894118, 0.894118), (0.7003614915704727, 0.988235, 0.988235), (0.7303253424134254, 0.901961, 0.901961), (0.7602891932563781, 0.839216, 0.839216), (0.7902530440993308, 0.768627, 0.768627), (0.8202168949422836, 0.709804, 0.709804), (0.8501807457852363, 0.639216, 0.639216), (0.880144596628189, 0.580392, 0.580392), (0.9101084474711417, 0.541176, 0.541176), (0.9400722983140946, 0.501961, 0.501961), (0.9700361491570473, 0.439216, 0.439216), (0.9880144596628189, 0.380392, 0.380392), (1.0, 0.34902, 0.34902)], 'green': [(0.0, 1.0, 1.0), (0.0004024604558944702, 1.0, 1.0), (0.010061511397361757, 0.988235, 0.988235), (0.020123022794723514, 0.988235, 0.988235), (0.030184534192085263, 0.968627, 0.968627), (0.04024604558944703, 0.945098, 0.945098), (0.05030755698680878, 0.905882, 0.905882), (0.06036906838417053, 0.862745, 0.862745), (0.07043057978153228, 0.803922, 0.803922), (0.08049209117889405, 0.741176, 0.741176), (0.0905536025762558, 0.678431, 0.678431), (0.10061511397361755, 0.607843, 0.607843), (0.11067662537097932, 0.545098, 0.545098), (0.12073813676834105, 0.486275, 0.486275), (0.13079964816570283, 0.411765, 0.411765), (0.14086115956306455, 0.305882, 0.305882), (0.15092267096042633, 0.239216, 0.239216), (0.1609841823577881, 0.180392, 0.180392), (0.17104569375514983, 0.121569, 0.121569), (0.1811072051525116, 0.054902, 0.054902), (0.19116871654987333, 0.039216, 0.039216), (0.2012302279472351, 0.047059, 0.047059), (0.20124022794723512, 0.180392, 0.180392), (0.226195791128397, 0.203922, 0.203922), (0.25115135430955887, 0.25098, 0.25098), (0.27610691749072075, 0.282353, 0.282353), (0.3010624806718826, 0.313725, 0.313725), (0.3260180438530445, 0.341176, 0.341176), (0.35097360703420644, 0.376471, 0.376471), (0.37592917021536826, 0.407843, 0.407843), (0.4008847333965302, 0.431373, 0.431373), (0.425840296577692, 0.454902, 0.454902), (0.45079585975885395, 0.478431, 0.478431), (0.4757514229400158, 0.513725, 0.513725), (0.5007069861211777, 0.556863, 0.556863), (0.5256625493023396, 0.592157, 0.592157), (0.5506181124835015, 0.639216, 0.639216), (0.5755736756646633, 0.690196, 0.690196), (0.6005292388458252, 0.741176, 0.741176), (0.6254848020269871, 0.784314, 0.784314), (0.650440365208149, 0.819608, 0.819608), (0.6753959283893108, 0.878431, 0.878431), (0.7003514915704727, 0.941176, 0.941176), (0.7003614915704727, 0.921569, 0.921569), (0.7303253424134254, 0.752941, 0.752941), (0.7602891932563781, 0.627451, 0.627451), (0.7902530440993308, 0.498039, 0.498039), (0.8202168949422836, 0.411765, 0.411765), (0.8501807457852363, 0.333333, 0.333333), (0.880144596628189, 0.25098, 0.25098), (0.9101084474711417, 0.180392, 0.180392), (0.9400722983140946, 0.105882, 0.105882), (0.9700361491570473, 0.043137, 0.043137), (0.9880144596628189, 0.019608, 0.019608), (1.0, 0.0, 0.0)], 'red': [(0.0, 1.0, 1.0), (0.0004024604558944702, 1.0, 1.0), (0.010061511397361757, 0.984314, 0.984314), (0.020123022794723514, 0.988235, 0.988235), (0.030184534192085263, 0.980392, 0.980392), (0.04024604558944703, 0.980392, 0.980392), (0.05030755698680878, 0.968627, 0.968627), (0.06036906838417053, 0.968627, 0.968627), (0.07043057978153228, 0.960784, 0.960784), (0.08049209117889405, 0.94902, 0.94902), (0.0905536025762558, 0.941176, 0.941176), (0.10061511397361755, 0.929412, 0.929412), (0.11067662537097932, 0.921569, 0.921569), (0.12073813676834105, 0.909804, 0.909804), (0.13079964816570283, 0.890196, 0.890196), (0.14086115956306455, 0.8, 0.8), (0.15092267096042633, 0.760784, 0.760784), (0.1609841823577881, 0.678431, 0.678431), (0.17104569375514983, 0.6, 0.6), (0.1811072051525116, 0.501961, 0.501961), (0.19116871654987333, 0.4, 0.4), (0.2012302279472351, 0.301961, 0.301961), (0.20124022794723512, 0.219608, 0.219608), (0.226195791128397, 0.25098, 0.25098), (0.25115135430955887, 0.301961, 0.301961), (0.27610691749072075, 0.329412, 0.329412), (0.3010624806718826, 0.360784, 0.360784), (0.3260180438530445, 0.388235, 0.388235), (0.35097360703420644, 0.419608, 0.419608), (0.37592917021536826, 0.45098, 0.45098), (0.4008847333965302, 0.470588, 0.470588), (0.425840296577692, 0.490196, 0.490196), (0.45079585975885395, 0.509804, 0.509804), (0.4757514229400158, 0.541176, 0.541176), (0.5007069861211777, 0.580392, 0.580392), (0.5256625493023396, 0.611765, 0.611765), (0.5506181124835015, 0.65098, 0.65098), (0.5755736756646633, 0.701961, 0.701961), (0.6005292388458252, 0.74902, 0.74902), (0.6254848020269871, 0.788235, 0.788235), (0.650440365208149, 0.819608, 0.819608), (0.6753959283893108, 0.878431, 0.878431), (0.7003514915704727, 0.941176, 0.941176), (0.7003614915704727, 0.890196, 0.890196), (0.7303253424134254, 0.67451, 0.67451), (0.7602891932563781, 0.529412, 0.529412), (0.7902530440993308, 0.392157, 0.392157), (0.8202168949422836, 0.313725, 0.313725), (0.8501807457852363, 0.25098, 0.25098), (0.880144596628189, 0.184314, 0.184314), (0.9101084474711417, 0.133333, 0.133333), (0.9400722983140946, 0.086275, 0.086275), (0.9700361491570473, 0.05098, 0.05098), (0.9880144596628189, 0.05098, 0.05098), (1.0, 0.058824, 0.058824)]}matplotlib.cm.register_cmap(    'colormoves_2', cmap=LinearSegmentedColormap('colormoves_2', colormap2, 256))matplotlib.cm.register_cmap(    'colormoves_3', cmap=LinearSegmentedColormap('colormoves_3', colormap3, 256))